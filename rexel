#!/bin/lua

-- Rexel Interpreter 1.4.0

-- version option
local version = "Rexel Version 1.4.0"

local args = {...}  -- Capture command-line args

if args[1] == "--version" then
    print("Rexel Version: " .. version)
    os.exit(0)  -- Exit after showing version info
end

-- Module Loading and Error Handling
local loaded_modules = {}

function import(module_name)
    if loaded_modules[module_name] then
        return  -- Module already loaded
    end

    local path = "/usr/local/share/rexel/" .. module_name .. ".rx"
    local file = io.open(path, "r")
    if not file then
        error("Module not found: " .. module_name)
    end

    local code = file:read("*a")
    file:close()
    loaded_modules[module_name] = true  -- Mark module as loaded

    local func = load(code)
    if func then
        func()
    end
end

-- File I/O Functions
function readFile(filename)
    local file = io.open(filename, "r")
    if not file then
        error("Unable to read file: " .. filename)
    end
    local content = file:read("*a")
    file:close()
    return content
end

function writeFile(filename, content)
    local file = io.open(filename, "w")
    if not file then
        error("Unable to write to file: " .. filename)
    end
    file:write(content)
    file:close()
end

-- Threading support using LuaLanes (install via luarocks)
local lanes = require "lanes".configure()

function run_parallel(funcs)
    local threads = {}
    for _, func in ipairs(funcs) do
        table.insert(threads, lanes.gen("*", func)())
    end
    -- Wait for threads to finish
    for _, thread in ipairs(threads) do
        thread[1]  -- Join the thread
    end
end

local function create_lock()
    local lock = lanes.locks.new()
    return lock
end

local function create_queue()
    local queue = lanes.queue.new()
    return queue
end

-- Enhanced error recovery
function try(func)
    local success, result = pcall(func)
    if not success then
        print("Error occurred: " .. result)
        -- Fallback behavior
        return nil
    end
    return result
end

function define_error_handler(handler)
    _G.custom_error_handler = handler
end

local function handle_error(err)
    if _G.custom_error_handler then
        _G.custom_error_handler(err)
    else
        print("Error: " .. err)
    end
end

-- Run external commands (run command)
function run(command, ...)
    local args = {...}
    local cmd = command .. " " .. table.concat(args, " ")
    os.execute(cmd)
end

-- Debugging utility
function debug_variable(var)
    print("Variable Value: " .. tostring(var))
end

-- Basic Hash Map Implementation
local function create_map()
    local map = {}
    function map:set(key, value)
        self[key] = value
    end
    function map:get(key)
        return self[key]
    end
    return map
end

-- Set Implementation
local function create_set()
    local set = {}
    function set:add(value)
        self[value] = true
    end
    function set:contains(value)
        return self[value] ~= nil
    end
    return set
end

-- Advanced Data Structures: Linked List
local function create_linked_list()
    local list = {head = nil, tail = nil}
    function list:append(value)
        local node = {value = value, next = nil}
        if not self.head then
            self.head = node
            self.tail = node
        else
            self.tail.next = node
            self.tail = node
        end
    end
    function list:iterate()
        local current = self.head
        return function()
            if current then
                local value = current.value
                current = current.next
                return value
            end
        end
    end
    return list
end

-- Evaluate Expressions in the script (for REPL)
local function evaluate_expression(input)
    local env = setmetatable({}, {__index = _G})
    local func, err = load("return " .. input, "expression", "t", env)
    if not func then
        func, err = load(input, "expression", "t", env)
    end
    if func then
        local success, result = pcall(func)
        if success then
            return result
        else
            return "Runtime Error: " .. result
        end
    else
        return "Error: " .. err
    end
end

local function profile(func)
    local start_time = os.clock()
    local result = func()
    local end_time = os.clock()
    print("Execution time: " .. (end_time - start_time) .. " seconds")
    return result
end

-- Extending the REPL with Custom Commands
local custom_commands = {}

function register_command(name, func)
    custom_commands[name] = func
end

-- REPL Function with Enhancements
local history = {}
local history_index = 0

local function add_to_history(cmd)
    table.insert(history, cmd)
    history_index = #history + 1
end

local function get_from_history(direction)
    if direction == "up" then
        history_index = math.max(1, history_index - 1)
    elseif direction == "down" then
        history_index = math.min(#history + 1, history_index + 1)
    end
    return history[history_index] or ""
end

local function show_help()
    print("Available commands:")
    print(" - run <command> : Run an external command")
    print(" - exit : Exit the REPL")
    print(" - help : Show this help message")
    -- Add more commands as needed
end

local function autocomplete(input)
    -- Implement simple command autocompletion
    local commands = {"run", "exit", "help"}
    for _, cmd in ipairs(commands) do
        if cmd:sub(1, #input) == input then
            return cmd
        end
    end
    return input
end

function repl()
    while true do
        io.write("Rexel> ")
        local input = io.read()
        
        if input == "exit" then break end
        if input == "help" then show_help() end

        input = autocomplete(input)
        add_to_history(input)

        if custom_commands[input] then
            custom_commands[input]()
        else
            local func, err = load(input)
            if not func then
                print("Error: " .. err)
            else
                local success, result = pcall(func)
                if success then
                    if result then
                        print(result)
                    else
                        print("nil")
                    end
                else
                    print("Runtime Error: " .. result)
                end
            end
        end
    end
end

-- Main interpreter execution
local arg = arg or {}

-- Function to run a given command externally
function run_external_command(command)
    local handle = io.popen(command)
    local result = handle:read("*a")
    handle:close()
    return result
end

if #arg > 0 then
    -- If arguments are provided, execute the script
    local script = arg[1]
    local f = loadfile(script)
    if f then
        local success, result = pcall(f)
        if not success then
            print("Error running script: " .. result)
            os.exit(1)
        end
    else
        print("Error: Could not load script: " .. script)
        os.exit(1)
    end
else
    -- Enter interactive mode (only if no arguments are passed)
    print("Entering Rexel Interactive Mode (type 'exit' to quit)")
    while true do
        io.write("Rexel> ")
        local input = io.read()

        -- Check if user wants to exit the interactive mode
        if input == "exit" then
            print("Exiting Rexel...")
            os.exit(0)
        end

        -- Handle the `run` command to run external programs
        if input:match("^run%s+(.+)$") then
            local command = input:match("^run%s+(.+)$")
            local result = run_external_command(command)
            print(result)
        else
            -- Process input here
            local success, result = pcall(function() return evaluate_expression(input) end)
            if success then
                if result then
                    print(result)
                else
                    print("nil")  -- Explicitly print nil if no return value
                end
            else
                print("Error: ", result)  -- Print the error message
            end
        end
    end
end
